project
=======

import maze import turtle import random  def turn_left():    mario.dir = maze.LEFT  def turn_right():    mario.dir = maze.RIGHT  def turn_up():    mario.dir = maze.UP  def turn_down():    mario.dir = maze.DOWN  def is_wall(cell):     """Returns true if the given cell contains an outer on inner wall"""     return (abs(cell.x) == maze.width + 1)   or   \            (abs(cell.y) == maze.height + 1)  or   \            cell in walls   # inner wall  def debug():     maze.clear_cell(drawer, maze.Cell(6,6))     mario.move_to_cell(maze.Cell(0,0))  def update():    if (mario.dir != maze.STAND):        old_heading = mario.heading()        if (mario.dir == maze.LEFT): new_heading = 180        elif (mario.dir == maze.RIGHT): new_heading = 0        elif (mario.dir == maze.UP): new_heading = 90        else: new_heading = 270        if (old_heading != new_heading):  # turn mario           old_speed = mario.speed()           mario.speed(0)  # turn off animation           mario.setheading(new_heading)           mario.speed(old_speed)        # determine new cell assuming mario can move        new_cell = maze.Cell(mario.cell.x, mario.cell.y)  # copy current cell        if (mario.dir == maze.LEFT): new_cell.x -= 1        elif (mario.dir == maze.RIGHT): new_cell.x += 1        elif (mario.dir == maze.UP): new_cell.y += 1        else: new_cell.y -= 1         if (not is_wall(new_cell)):           mario.forward(maze.cell_size)           mario.cell = new_cell           if(mario.cell in items):             mario.score += 10             score_drawer.undo()  # clear latest text             score_drawer.write("SCORE = {0}".format(mario.score), move=False, \                                align="center", font=("Arial", 9, "normal"))        else:  # mario can't move           mario.dir = maze.STAND   # until the user presses antoher arrow key, just stand         wn.title("Mario at ({0}, {1})  SCORE={2}".format(mario.cell.x, mario.cell.y, mario.score))      wn.ontimer(update, 200)  wn = turtle.Screen() wn.bgcolor(maze.bg_color) wn.title("Maze") wn.setup(710,710) wn.screensize(700,700)  wn.onkey(turn_left, "Left") wn.onkey(turn_right, "Right") wn.onkey(turn_up, "Up") wn.onkey(turn_down, "Down")  wn.onkey(debug, "d")  mario = maze.MazeTurtle() # mario.moveToCell(5,5) mario.shapesize(0.7) mario.color("darkblue", "blue")  drawer = turtle.Turtle() score_drawer =  turtle.Turtle()  for t in [drawer, score_drawer]:     t.fillcolor("black")     t.speed(0)     t.hideturtle()     t.penup() (x,y) = maze.Cell(0,maze.height+2).to_coord() score_drawer.goto(x,y-8) score_drawer.write("SCORE = {0}".format(mario.score), move=False, \                                align="center", font=("Arial", 9, "normal"))  # draw outer walls  short_side = maze.cell_size long_side_w = (2*maze.width+3)*maze.cell_size long_side_h = (2*maze.height+3)*maze.cell_size (x,y) = maze.Cell(-maze.width-1, maze.height+1).to_coord(True) maze.fill_rect(drawer,x,y,short_side, long_side_h) maze.fill_rect(drawer,x,y,long_side_w,short_side) (x,y) = maze.Cell(-maze.width-1, -maze.height-1).to_coord(True) maze.fill_rect(drawer,x,y,long_side_w,short_side) (x,y) = maze.Cell(maze.width+1, maze.height+1).to_coord(True) maze.fill_rect(drawer,x,y,short_side,long_side_h)  rng = random.Random()  items = [maze.Cell(-7, -5), maze.Cell(6,6), maze.Cell(-7, 5), maze.Cell(6, -8)] drawer.color("black", "darkgreen") drawer.shape("circle") drawer.shapesize(0.8) for cell in items:     (x,y) = cell.to_coord()     drawer.goto(x,y)     drawer.stamp() ##    drawer.goto(x,y-(maze.cell_size/2)+2) ##    drawer.begin_fill() ##    drawer.circle((maze.cell_size / 2) - 3) ##    drawer.end_fill()  # draw inner walls  walls = [] wall_count = 20 while (wall_count > 0):    i = rng.randint(-maze.width+1, maze.width-1) # inner walls not adjacent to outer walls    j = rng.randint(-maze.height+1, maze.height-1)    new_cell = maze.Cell(i,j)    if ((i == 0 and j == 0) or new_cell in walls or new_cell in items):       continue    else:       walls.append(new_cell)       wall_count -= 1 print(walls)  drawer.fillcolor("black") for cell in walls:     (x,y) = cell.to_coord(True)     # maze.fill_rect(drawer, x, y, maze.cell_size, maze.cell_size)      # use the below code to draw squares a little bit smaller than the full cell     x += 1     y -= 1     maze.fill_rect(drawer, x, y, maze.cell_size-2, maze.cell_size-2)  update()   wn.listen()  # listen events on this window wn.mainloop()   # keep the window open
